#TCP/IP
‌‌‌　　TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于**传输层**协议。其中TCP提供IP环境下的数据可靠传输，它提供的服务包括==数据流传送、可靠性、有效流控、全双工操作和多路复用==。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；而UDP则不为IP提供可靠性、 流控或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。 TCP支持的应用协议主要有：Telnet、FTP、SMTP等； UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。 TCP/IP协议与低层的数据链路层和物理层无关，这也是TCP/IP的重要特点。

| TCP                    | UDP                  |
| ---------------------- | -------------------- |
| 传输控制协议           | 用户数据报协议       |
| 可靠的、面向连接的协议 | 不可靠、无连接的服务 |

‌‌‌　　TPC/IP是基于TCP/IP这两个最初的协议之上的不同通信协议的大集合。

‌‌‌　　![[Pasted image 20230813213228.png]]

‌‌‌　　![[Pasted image 20230813221952.png]]
‌‌‌　　**应用层** 为操作系统或网络程序提供访问网络服务的接口。应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等
‌‌‌　　**表示层** 将应用处理的信息转换为合适网络传输的格式，或将来自下一层数据转换为上层能够处理的格式。数据的表示、安全、压缩。
‌‌‌　　**会话层** 负责建立和断开通信连接(数据流动的逻辑通路)，以及数据的分割等数据传输相关的管理。
‌‌‌　　**传输层** 管理两个节点之间的数据传输。负责可靠传输（确保数据）
‌‌‌　　**网络层** 地址管理与路由选择，在这一层，数据的单位称为数据包（packet）(路由器)
‌‌‌　　**数据链路层**  互连设备之间传送和识别数据帧(交换机)。
‌‌‌　　**物理层** 以“0”“1”代表电压高低，灯光的闪灭。物理层数据单位为比特（bit）,中继器、集线器、双绞线在物理层工作。

‌‌‌　　发送方由第七层到第一层 由上到下按照顺序传送数据，每个分层在处理上层传递的数据时，附上当前层协议所必须的 "首部"信息。接收方由第一层到第七层 由下到上按照顺序传递数据，每个分层对接收到的数据进行 "首部"与"内容"分离，在转发给上一层。最终将发送的数据恢复为原始数据。

|                              客户端                              |            |               服务端                |
|:----------------------------------------------------------------:|:----------:|:-----------------------------------:|
|             根据HTTP协议组装数据包 ==GET/HTTP/1.1==              |   应用层   |        GET/HTTP/1.1 报文解析        |
|      增加tcp头部，包含端口号序列号等 ==TCP头GET/HTTP/1.1==       |   传输层   |               TCP解析               |
|        增加IP头部，包含IP源地址 ==IP头/TCP/GET/HTTP/1.1==        | 网络互联层 |   IP报文解析 传送数据包，确定路由   |
| 增加以太网头部包含MAC地址等 ==以太网头/IP头/TCP头/GET/HTTP/1.1== | 网络访问层 | 根据MAC地址，判断包是不是发给自己的 |
|                                                                  |   物理层   |                                     |

## 传输方式分类
‌‌‌　　1、发送数据之前，需要在收发主机之间建立一条通信线路，在通信传输前后，专门进行建立和断开连接的处理，如果与对端之间无法通信，可避免发送无谓的数据
‌‌‌　　2、无需确认对端是否存在，发送端可随时发送数据。

## 报文、帧、数据包等的区别
‌‌‌　　报文在传输过程中会不断地==封装成分组、包、帧来传输==，封装的方式就是添加一些控制信息组成的首部，那些就是报文头。
‌‌‌　　应用层：报文（message），一般指完整的信息，传输层实现报文交付，位于应用层的信息分组称为报文；
‌‌‌　　传输层：报文段（segment），组成报文的每个分组；
‌‌‌　　网络层：分组（packet）是网络传输中的二进制格式单元，数据包（datapacket）是TCP/IP通信协议传输中的数据单位；通过网络传输的数据基本单元，包含一个报头和数据本身，其中报头描述了数据的目的地及其与其他数据之间的关系，可以理解为数据传输的分组，我们将通过网络传输的基本数据单元称为数据报（Datagram）；
‌‌‌　　链路层：帧（frame），数据链路层的协议数据单元，为了保证数据的可靠传输，把用户数据封装成帧；
‌‌‌　　物理层：PDU（bit），协议数据单元；
‌‌‌　　<font color=#ff9900>抓包，抓到的是传输层的包packet/frame/Datagram/segment是存在于同条记录中的，这些是基于所在协议层的不同取了不同的名字。</font>


‌‌‌　　![[Pasted image 20230814223535.png]]

### TCP 首部各字段的意义和作用
‌‌‌　　TCP首部最小为20字节，这20字节分为5行，每行4个字节也就是32个位。 
#### 源端口和目的端口 Port 源端口号：
‌‌‌　　16位的源端口中包含初始化通信的端口。源端口和源IP地址的作用是标识报文的返回地址。 
#### 目的端口号：
‌‌‌　　16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。计算机通过端口号识别访问哪个服务,比如http服务或ftp服务，发送方端口号是进行随机端口，目标端口号决定了接收方哪个程序来接收 分别占用16位，也就是端口号最大是2^16，所以端口号的范围是0~65536 
端口号的分配： 
- 知名端口号一般位于：1 --- 255 之间 256 --- 1023的端口号，通常是由Unix系统占用（系统占用） 
- 1024 ---5000 是大多数TCP、IP实现的临时分配 
- 大于5000的一般是给其他服务预留的（Internet上并不常用的服务） 

#### 序号 Sequence Number 
TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。 
#### 确认号 Acknowledgemt Number
占 4 个字节，表示期望收到对方下一个报文段的序号值。 TCP 的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。 就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。 那么，确认报文，就会包含确认号。 例如，通讯的一方收到了第一个 25kb 的报文，该报文的 序号值=0，那么就需要回复一个确认报文，其中的确认号 = 25600.
#### 数据偏移 Offset 
占 0.5 个字节 (4 位)。 这个字段实际上是指出了 TCP 报文段的首部长度 ，它指出了 TCP报文段的数据起始处 距离 TCP报文的起始处 有多远。（注意 数据起始处 和 报文起始处 的意思） 一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大长度。 
#### 保留 Reserved 
占 0.75 个字节 (6 位)。 保留为今后使用，但目前应置为 0。 
#### 标志位 TCP Flags 标志位，一共有 6 个，分别占 1 位，共 6 位 。 每一位的值只有 0 和 1，分别表达不同意思。
- ACK：确认序号有效 
- RST：重置连接 
- SYN：发起了一个新连接 
- FIN：释放一个连接 
- 
#### 确认ACK (Acknowlegemt) 当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。 一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。为0表示数据段不包含确认信息，确认号被忽略。 TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。 推送 PSH (Push) 当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。 
#### 复位 RST (Reset) 当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。 一般称携带 RST 标志的 TCP 报文段为「复位报文段」。 
#### 同步 SYN (SYNchronization) 当 SYN = 1 的时候，表明这是一个请求连接报文段。 一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。 在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。 对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。 
#### 终止 FIN (Finis) 当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。 一般称携带 FIN 的报文段为「结束报文段」。 在 TCP 四次挥手释放连接的时候，就会用到该标志。 
#### 窗口大小 Window Size 占 2 字节。
该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。 例如，假如确认号是 701 ，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。
#### 校验和 TCP Checksum
占 2 个字节。 由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。 检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。 
#### 紧急指针 Urgent Pointer 
占 2 个字节。 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。 当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。 因此，紧急指针指出了紧急数据的末尾在报文段中的位置。

##  三次握手、四次挥手

- ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1
- SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。
- FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。
![[Pasted image 20230814232524.png]]
首先由Client发出请求连接即 SYN=1 ACK=0 (请看头字段的介绍), TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的32位序号是 seq=x，然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y, ack=x+1, 再然后 Client 再进行一次确认，但不用SYN 了，这时即为 ACK=1, seq=x+1, ack=y+1.

![[Pasted image 20230814233127.png]]
## 一些问题

### 1、TCP 分层
‌‌‌　　- **各层独立**：限制了依赖关系的范围，各层之间使用标准化接口，各层不需要知道上下层如何工作，增加或者修改一个应用层协议不会影响传输层协议
‌‌‌　　- **灵活性更好**：比如路由器不需要应用层和传输层，分层后路由器就可以只用加载更少的几个协议层
‌‌‌　　- **易于测试和维护**：提高了可测试性，可独立测试特定层，某一层有了更好的实现可以整体替换掉
‌‌‌　　- **能促进标准化**：每一层职责清楚，方便进行标准化

### 2、TCP三次握手
‌‌‌　　![[Pasted image 20230811200230.png]]
‌‌‌　　*①三次握手的本质是确认通信双方收发数据的能力  
‌‌‌　　首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。    于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。
‌‌‌　　②没有第三次确认，client可能会一直重传造成资源浪费。*

### 3、TCP四次挥手
‌‌‌　　![[Pasted image 20230811200435.png]]

### 4、为什么SYN/FIN不包含数据消耗一个序列号
‌‌‌　　凡是需要对端确认的，一定消耗TCP报文序列号。SYN和FIN需要对端确认，所以消耗一个序列号。

### 5、半连接队列。SYN Flood攻击
‌‌‌　　客户端大量伪造IP发送SYN包，服务端恢复ACK+SYN到一个未知ip地址，势必会造成服务端大量连接处于SYN_RCVD状态，而服务器的半链接队列大小是有限的，如果半链接队列满，则会出现无法处理正常请求的情况。


>**SYN Flood 攻击(洪泛攻击)**
   (1)攻击方大量伪造源地址发送SYN
> (2)服务器向伪造的地址发送SYN+ACK
> (3)未知服务器回复拒绝或不回复
> (4)没有接收到第三次握手的服务器半连接队列满，无法处理其他请求


### 6、TCP快速打开(TFO)原理
‌‌‌　　TCP Fast Open
‌‌‌　　TFO是在原来TCP协议上的扩展协议，它的主要原理就在发送第一个SYM包的时候就开始传数据了，不过它要求当前客户端之前已经完成过**正常**的三次握手
‌‌‌　　快速打开分两个阶段：请求Fast Open Cookie 和真正开始TCP Fast Open
‌‌‌　　![[Pasted image 20230811212335.png]]

‌‌‌　　TFO 优点 :
‌‌‌　　可以利用握手去除一个往返的RTT
‌‌‌　　可以防止SYN Flood 攻击

### 7、TCP报文中的时间戳作用
‌‌‌　　![[Pasted image 20230811213220.png]]
‌‌‌　　TCP Timestamps Option由四部分构成：类别(kind)，长度(length)，发送方时间戳(TS value)，回显时间戳(TS Echo Reply)
‌‌‌　　TCP 时间戳功能：
‌‌‌　　(1)计算往返时延RTT(round-trip Time) 启用时间戳后，ACK包里包含了TSval 和TSecr。无论正常确认包还是重传确认包，都可以通过这两个值计算出RTT。
‌‌‌　　(2)防止序列号回绕问题：TCP的序列号用32bit来表示，因此在2<sup>32</sup>字节的数据传输后序列号就会溢出回绕。TCP窗口经过窗口缩放可以最高到1GB(2<sup>30</sup>),在高速网络中，序列号在很短时间内就会被重复使用。

### 8、TCP超时重传时间
‌‌‌　　TCP具有超时重传机制，即隔一段时间没有等到数据包回复时，重传这个数据包。这个重传间隔也被称为超时重传时间(Retransmission Time Out , RTO)。
‌‌‌　　RTT波动较小时，可以取平均值。
‌‌‌　　经典算法引入了平滑往返时间（SRTT）,经过平滑后的RTT值，每测量一次就对SRTT做一次更新计算。

### 9、TCP流量控制
‌‌‌　　对于发送端和接收端而言，TCP需要把发送的数据放到发送缓存区，将接收到的数据放到接收缓存区。
‌‌‌　　而流量控制要做的事情，就是通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能继续发送了。
‌‌‌　　为了控制发送端速率，接收端会告知客户端自己接收窗口(rwnd) ,也就是接收缓冲区空闲部分。


### 10、TCP 中的Keep-alive
‌‌‌　　一个TCP连接上，如果通信双方都不向对方发送数据，那么TCP连接不会有任何数据交换。
‌‌‌　　假设应用程序是一个web服务器，客户端发出三次握手以后故障宕机或断网，对于web服务器，下个数据包永远无法到来，但web服务器无法知道。
‌‌‌　　为了检测长时间死连接，设计keepalive.
‌‌‌　　keepalive作用是探测对端的连接有没有失效，通过定时发送探测包来探测连接的对端是否存活，不过默认7200s没有数据包交互才会发送keepalive探测包，往往因为时间太久，不会开启keepalive,而是在应用层使用心跳机制。

>**心跳机制**
>就是每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息如果服务端几分钟内没有收到客户端信息则视客户端断开。 发包方：可以是客户也可以是服务端，看哪边实现方便合理。 心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。心跳包主要也就是用于长连接的保活和断线处理。一般的应用下，判定时间在30-40秒比较不错。如果实在要求高，那就在6-9秒。

### 11、TCP 端口号
‌‌‌　　port,在TCP头里源端口和目标端口。
‌‌‌　　端口号由两字节的整数表示，一台主机最大允许65536个端口号。
‌‌‌　　- 熟知端口号0~1023  http(80) https(443) ssh(22)
‌‌‌　　- 已登记端口号1024~49151 MySql(3306) Redis(6379) MongDB(27017)
‌‌‌　　- 临时端口号49152~65535

### 12、telnet
‌‌‌　　检查端口是否打开。
‌‌‌　　使用 ==telnet [domainname or  ip] [port]== 可以用于测试远端server指定端口是否可达。

### 13、netstat命令

### 14、tcpdump
‌‌‌　　tcpdumb 是一个*命令行*网络流量分析工具，一般用于抓TCP包。
### 15、wireshark

### 16、TCP 与 UDP区别
‌‌‌　　![[Pasted image 20230812231229.png]]![[Pasted image 20230812231417.png]]

#### 17、为什么挥手比握手多一次
因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。